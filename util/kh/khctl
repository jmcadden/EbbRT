#!/bin/bash

#####################################
#
#  IBM Coporation
#  Project kittyhawk
#
# khctl simple inteface for managing
# nodes and networks
# main interface function is acquireNodes
#
#####################################
if [[ $BASH_VERSION != 3.1.* ]]; then shopt -s compat31; fi

# General Settings
shopt -s extglob
PATH=$PATH:/sbin
declare -r KHBASEDIR=${KHCTL_BASEDIR:-/home/kh}
declare -r KHCONSDIR=${KHCTL_CONSDIR:-$KHBASEDIR/Consoles}
declare -r KHCTLDIR=${KHCTL_CTLDIR:-$KHBASEDIR/Ctl}
declare -r KHTUPLEDIR=${KH_TUPLEDIR:-$KHBASEDIR/KHTuples}
declare -r KHTUPLECTRLDIR=${KH_TUPLECTRLDIR:-$KHCTLDIR}
declare -r KHCONIDFILE=${KHCTL_CONIDFILE:-$KHCTLDIR/ConID}
declare -r KHCONIDSTART=${KHCTL_CONIDSTART:-2}
declare -r KHCONIDEND=${KHCTL_CONIDEND:-$(printf "%d" 0xffffffff)}
declare -r KHPNETIDFILE=${KHCTL_PNETIDFILE:-$KHCTLDIR/PNetID}
declare -r KHINETID=${KHCTL_INETID:-0}
declare -r KHXNETID=${KHCTL_XNETID:255}
declare -r KHFREENETID=${KHCTL_FREENETID:-2}
declare -r KHPNETSRESERVED=${KHCTL_PNETSRESERVED:-3}
declare -r KHPNETIDSTART=${KHCTL_PNETIDSTART:-$KHPNETSRESERVED}
declare -r KHPNETIDEND=${KHCTL_PNETIDEND:-$(printf "%d" 0xffffffff)}
declare -r KHUSERPREFIX=${KHCTL_USERPREFIX:-con}
declare -r SESANETDIR=${SESA_NETDIR:-$KHBASEDIR/Networks}
declare -r SESAEMUCMD=${SESA_EMUCMD:-"/opt/bin/qemu-system-x86_64"}
declare -r KHCTRLID=${KHCTL_CTRLID:-0}
declare -r FREEOWNER='_FREE_'
declare -r FREEPNET=$KHFREENETID
declare -r FREEINETFLG=0
declare -r FREEXNETFLG=0
declare -r FREECONID=$KHCTRLID
declare -r FREENETADDR='0.0.0.0'
declare BUFFERVAR
declare -i BUFFERTTY=1
declare SESAMNTDIRA=${SESA_MNTDIR_A:=""}
declare SESAMNTDIRB=${SESA_MNTDIR_B:=""}
declare SESADEBUG=${SESA_DEBUG:=""}
declare SESABIOS=${SESA_BIOS:=""}
declare SESATAP=${SESA_TAP:=""}
typeset dofunc

declare  createCon=SESAcreateCon
declare  createConUser=SESAcreateConUser

# Allocation Type Settings
declare -r SESAMAXNODES=${SESA_MAX_NODES:-4}
declare  configNodes=${SESA_Config_Nodes:=HPCloudConfigNodes}
declare  allocNodes=${SESA_Alloc_Nodes:=HPCloudAllocNodes}
declare  freeNodes=${SESA_Free_Nodes:=HPCloudFreeApp}

function getNatIP
{
    if [[ -a $KHNATIPFILE ]]; then
	cat $KHNATIPFILE
    fi
}

function myIPAddrs
{
   local net
   local ip
   local rest
   local rc

   # If no argument all configured ip address are returned
   # otherwise only for the speccified interface
   ifconfig $1 2> /dev/null | grep 'inet addr' | while read net ip rest
   do
     ip=${ip##addr:}
     if [[ $ip != 127.0.0.1 ]]
     then
        echo $ip
     fi
   done
}

function myInterfaces
{
   local iface
   local rest

   ifconfig | grep Link | while read iface rest
   do
      echo $iface
   done
}

function interfaceAddr
{
  local iface
  local ip

  if [[ -z $1 ]]
  then
    echo "USAGE: internfaceAddr <ip>" >&2
    return 255
  fi

  for iface in $(myInterfaces)
  do
      ip=$(ifconfig $iface | grep 'inet addr')
      ip=${ip#*:}
      ip=${ip%% *}
      if [[ $ip = "$1"* ]]
      then
        echo $iface
        return 0
      fi
  done

  return 255
}


#ttyRawWrite()
#{
#  local data="$1"
#  local tty="$2"
#
#  echo "$data" > $tty
#  sleep 0.05
#}
#
#writeTTY()
#{
#  local data="$1"
#  local tty="$2"
#
#  if (( $BUFFERTTY == 0 ))
#  then
#    ttyRawWrite "$data" $tty
#  else
#    TTYBUFFERVAR="${TTYBUFFERVAR}$data
#"
#  fi
#}
#
#getRespfile()
#{
#    echo /tmp/$$.respfile.$RANDOM
#}



SESAcreateNet()
{
  local nid=$1
  local tapcmd=""
  local dir=$SESANETDIR/$nid
  [[ -n 2 ]] && tap=$2

  # check if network exists
  if [[ -a $dir/pid ]]
  then
      return 0
  fi

  if [[ ! -d $dir ]] && ! mkdir -p $dir; then
    echo "YIKES mkdir of $dir failed" > /dev/stderr
    return 255
  fi

  # ip directory
  mkdir -p $dir/ip

  # optional tap interface
  if [[ -n $tap ]]; then
    if [[ $( ifconfig | grep -o $tap) ]]; then
      tapcmd="-t $tap"
    else
      echo "Error: unable to locate $tap"
    fi
  fi

  vde_switch $tapcmd -d -s $dir/sock -M $dir/mgmt -p $dir/pid
}

function SESAcleanAll
{
  local consoles=( $(tupleCmd echo Node '!(*:_FREE_:*:*:*)') )
  local files=( ${consoles[@]/*:/$KHCONSDIR/} )
  kill $( cat ${files[@]/%//nodes/\*/pid} | sort -u )
  #verify
  sleep 3
  local rem=$( ps --no-heading -o pid $( cat ${files[@]/%//nodes/\*/pid} ))
  if [[ ${#rem[@]} > 1 ]]
  then
    echo "ERROR: These processes escaped death"
    echo ${rem[@]}
  fi
  #clean networks
  kill $( cat $SESANETDIR/*/pid   )

  #clear db
  rm -rf $KHCTLDIR/*
  rm -rf $KHTUPLEDIR/*
  rm -rf $KHCONSDIR/*
  rm -rf $SESANETDIR/*
}


function SESAFreeApp
{
  app=$1
  if [[ -z $app ]]; then
      echo "Error: No app name"
      exit 1
  fi

  local consoles=( $(tupleCmd echo Node "*:$app:*:*:*") )
  if [[ $consoles == "*:$app:*:*:*" ]];then
    exit 1
  fi

  # kill the processes 
  local files=( ${consoles[@]/*:/$KHCONSDIR/} )
  kill $( cat ${files[@]/%//nodes/\*/pid} | sort -u ) 2> /dev/null

  for i in ${consoles[@]}
  do
    nodes+=($( echo $i | cut -d ':' -f 1 ))
  done

  lock tuples
  locked_rm_nodes "*" "$1" "*" "*" "*" "*"
  for j in ${nodes[@]}
  do
    locked_touch_nodes "$j" "$FREEOWNER" "$FREEPNET"\
      "$FREEINETFLG" "$FREEXNETFLG" "$FREECONID" "$FREENETADDR"
  done
  unlock tuples
}

function SESACleanApp
{
  app=$1
  if [[ -z $app ]]; then
      echo "Error: No app name"
      exit 1
  fi

  local consoles=( $(tupleCmd echo Node "*:$app:*:*:*") )
  if [[ $consoles == "*:$app:*:*:*" ]];then
    echo "Error: App not found. Use khls to list active apps"
    exit 1
  fi
  local network=( $(tupleCmd echo Pnet "*:$app") )
  local files=( ${consoles[@]/*:/$KHCONSDIR/} )
  local net=$( echo $network | cut -d ':' -f 1 )

  if [[ ! (${#consoles[@]} > 0) ]]; then
    echo "ERROR: $app not found"
    exit 1
  fi
  #TODO: abstract away network cleanup 
  if [[ -a $SESANETDIR/$net/pid ]]; then
    kill $( cat $SESANETDIR/$net/pid ) > /dev/null 2>&1
  fi

  # clean up resources
  $freeNodes $app

  # clean up tuples
  lock tuples
  locked_rm_users "$1" "*"
  locked_rm_pnets "$net" "$1"
  unlock tuples
  
  # clean up files
  rm -rf $SESANETDIR/$net
  rm -rf $( echo ${files[@]} | sort -u )
}

function SESAdisplayApp
{
  app=$1
  if [[ -z $app ]]; then
      echo "Error: No app name"
      exit 1
  fi
  local nodes=()
  local consoles=( $(tupleCmd echo Node "*:$app:*:*:*") )
  if [[ $consoles == "*:$app:*:*:*" ]];then
    echo "Error: App not found. Use khls to list active apps"
    exit 1
  fi

  local network=( $(tupleCmd echo Pnet "*:$app") )
  local files=( ${consoles[@]/*:/$KHCONSDIR/} )
  local net=$( echo $network | cut -d ':' -f 1 )
  local ipdir=$SESANETDIR/$net/ip

  if [[ ! (${#consoles[@]} > 0) ]]; then
    echo "ERROR: $app not found"
    exit 1
  fi

  local ips=( $(cat ${ipdir/%//\*/addr} | sort -u ) )
  for i in ${ips[@]}
  do
    echo $i
  done
}

function SESAlistApp
{
  local consoles=( $(tupleCmd echo Node "!(*:_FREE_:*:*:*)") )
  local files=()

  for i in ${consoles[@]}
  do
    files+=($( echo $i | cut -d ':' -f 2 ))
  done

  for i in $( echo ${files[@]} | tr ' ' '\n' | sort -u | tr '\n' ' ' )
  do
    echo $i $( grep -o $i <<< ${files[*]} | wc -l )
  done
}

function SESAgenerateMac()
{
  local mac
  printf -v mac 'DE:AD:BE:EF:%02X:%02X' $((RANDOM%256)) $((RANDOM%256))
  echo $mac
}

SESAConfigNodes()
{
  local khuser=$1
  local pnetids=$2
  local inet=$3
  local xnet=$4
  local conid=$5
  local num=$6
  local nodes="$7"
  local basedir=$KHCONSDIR/$conid
  local dir
  local mac
  local n
  local -i p
  local -i j
  local -i i
  local -i ethoffset
  local inetdesc
  local tmp
  local netcmd=""
  local srlcmd=""
  local concmd=""
  local mntcmd=""
  local bioscmd=""
  local gdbcmd=""
  local kernel=""
  local ram="512"
  local -i gdbport=0

  # Private network construction
  for p in ${pnetids//,/ }
  do
    if [[ ! -a $SESANETDIR/$p/sock ]]
    then
      SESAcreateNet $p $SESATAP
    fi
  done

  # Shared networks
  ethoffset=0
  if (( $xnet == 1 ))
  then
    (( ethoffset++ ))
  fi
  if (( $inet == 1 ))
  then
    (( ethoffset++ ))
  fi

  # gdb debug
  if [[ $SESADEBUG ]]
  then
    gdbport=$SESADEBUG
  fi

  # node construction
  for n in ${nodes[@]}; do
    netcmd=""
    dir=$basedir/nodes/$n
    j=$ethoffset

    #ip directory
    ipdir=$SESANETDIR/$p/ip/$n
    mkdir -p $ipdir
    # setup network share for frontend instances
    # if (( $ethoffset > 0 ))
    # then
    #   SESAMNTDIRA=$ipdir
    # fi

    # external network
    if (( $xnet == 1 ))
    then
      mac=$(SESAgenerateMac)
      netcmd="$netcmd -net nic,vlan=1,model=virtio,macaddr=$mac -net bridge,vlan=1,br=brX"
      echo "$n: network_external eth0 $mac"
    fi

    # internal network
    if (( $inet == 1 ))
    then
      mac=$(SESAgenerateMac)
      netcmd="$netcmd -net nic,vlan=2,model=virtio,macaddr=$mac -net bridge,vlan=2,br=brI"
      echo "$n: network_internal eth1 $mac"
    fi

  # Private Networks Disabled... for now
  #
  #  # private network(s)
  #  for p in ${pnetids//,/ }; do
  #    mac=$(SESAgenerateMac)
  #    netcmd="$netcmd -net nic,vlan=$p,model=virtio,macaddr=$mac -net vde,vlan=$p,sock=$SESANETDIR/${p}/sock"
  #    echo "$n: network_application eth${j} $mac"
  #    (( j++ ))
  #  done

    # serial
    echo "$n: serial $dir/serial_log"
    srlcmd="-serial file:$dir/serial_log"
    #srlcmd="-serial unix:$dir/com_sock,server,nowait -serial file:$dir/serial_dump"

    # vde
    echo "$n: console $dir/vnc"
    concmd="-vnc unix:$dir/vnc -name $khuser:$conid:$n"

    # mount 1 (sdb1)
    if [[ -d $SESAMNTDIRA ]]
    then
      mntcmd="$mntcmd -drive file=fat:rw:$SESAMNTDIRA,index=1,cache=directsync,media=disk"
    fi
    # mount 2 (sdc1)
    if [[ -d $SESAMNTDIRB ]]
    then
      mntcmd="$mntcmd -drive file=fat:rw:$SESAMNTDIRB,index=2,cache=directsync,media=disk"
    fi

    # kernel
    if [[ -a $SESA_CONFIG ]]
    then
      kernel="-kernel $SESA_IMG -initrd $SESA_CONFIG"
    else
      kernel=$SESA_IMG
    fi

    # gdb debug
    if [[ $gdbport > 0 ]]
    then
      gdbcmd="-gdb tcp::$gdbport"
      gdbport=$gdbport+1
    fi

    $SESAEMUCMD $gdbcmd $netcmd $srlcmd $concmd -enable-kvm -m $ram -daemonize -pidfile $dir/pid $kernel $mntcmd > $dir/vnclog 2>&1
  done
  return 0
}


SESAcreateCon()
{
  local khuser=$1
  local conid=$2
  local nodes="$3"

  local dir=$KHCONSDIR/$conid

  if [[ -d $dir ]]
  then
      echo "ERROR: $dir already exists?!?" >&2
      return 255
  fi

  mkdir -p $dir
  mkdir -p $dir/nodes

  for n in ${nodes[@]}; do
    mkdir -p $dir/nodes/$n
  done

  echo "$nodes" > $dir/nodes/list
  echo "$khuser" > $dir/owner

  return 0
}


SESAcreateConUser()
{
  local khuser=$1
  local pnetid=$2
  local conid=$3
  local num=$4
  local nodes="$5"

  local dir=$KHCONSDIR/$conid
  local conuser=$KHUSERPREFIX${conid}
  local home=$dir/$conuser
  local shell=$dir/conshell
  local tty=$dir/tty

  if [[ ! -d $dir ]]
  then
    echo "ERROR: createConUser: $dir does not exist?!?" >&2
    return 255
  fi
  if ! mkdir $home
  then
    echo "ERROR: createConUser: could not make $home?!?" >&2
    return 255
  fi

  return 0
}

assignNodes()
{
  local khuser=$1
  local pnetid=$2
  local inet=$3
  local xnet=$4
  local conid=$5
  local numNodes=$6
  local nodes=( $7 )
  local conuser=$KHUSERPREFIX${conid}
  local conip
  local i
  local ip
  local configdesc
  local natip

  if $createCon $khuser $conid "${nodes[*]}"
  then
    if $createConUser $khuser $pnetid $conid $num "${nodes[*]}"
    then
      configdesc=$($configNodes $khuser $pnetid $inet $xnet $conid $num "${nodes[*]}")
      if (( $? == 0 ))
      then
       # if [[ 1 ]]; then # FIXME: cleanup
       #   echo "Platform: qemu-system-x86_64"
       # else 
       #   if [[ -n $SSH_CONNECTION ]]
       #   then
       #     conip=${SSH_CONNECTION% *}
       #     conip=${conip##* }
       #     natip=$(getNatIP)
       #     if [[ -n $natip ]]; then
       #       if [[ $conip = $(cat $KHXIPFILE) ]]; then
       #         conip=$natip
       #       fi
       #     fi
       #     echo $conuser@$conip
       #   else
       #     for i in $(myInterfaces)
       #     do
       #       ip=$(myIPAddrs $i)
       #       if [[ -n $ip ]]
       #       then
       #         echo $conuser@$ip
       #       fi
       #     done
       #   fi
       #   echo "protocol: uboot"
       # fi
        echo "$configdesc"
        echo "nodes: ${nodes[*]}"
        return 0
      fi
    fi
  fi
  return 255
}


SESAAllocNodes()
{
  # no preallocation needed for baremetal qemu
  return 0
}

#SNLXAllocNodes()
#{
#  return 255
#  local khuser=$1
#  local pnetids=$2
#  local inet=$3
#  local xnet=$4
#  local conid=$5
#  local num=$6
#  local nodes="$7"
#
#  base=.
#  ulnx=./ulnx
#   bare=./bare
#  imgtype=iso
#  export SESA_GET=khget
#  ##### SESA LINUX IMAGE ##################################
#  sesalnx=/opt/bin/sesalnx.img
#  sesalnx_id=/opt/bin/sesalnx_id
#  config_dir=/mnt/app
#  share_dir=/mnt/share
#  #########################################################
#  declare app
#  declare count
#  declare name
#  declare tap
#  declare debug
#  declare -i optcount=0
#
#  while getopts "n:t:g:DBK" OPT
#  do 
#    case $OPT in
#      ("n") name="$OPTARG"; (( optcount=optcount + 2));;
#      ("t") tap="$OPTARG"; (( optcount=optcount + 2));;
#    ("g") debug="$OPTARG"; (( optcount=optcount + 2));;
#    esac
#  done
#
#  shift $optcount
#  name=$1
#  count=$2
#
#  if [[ -z $name  || -z $count ]]
#  then
#    echo "USAGE: $0 [-t tap] <name> <count>"
#    echo "     -t  tap  : tap interface" 
#    echo "     -g  port : gdb server port" 
#    echo "     app      : application to associate nodes with"
#    echo "     count    : num of instances"
#    exit 1;
#  fi
#
#  if [[ -z $count ]]; then count=1; fi
#  echo "Loading $count node instances in $name"
#
#  if [[ -n $tap ]]; then 
#    export SESA_TAP=$tap
#  fi
#
#  if [[ -n $debug ]]; then 
#    export SESA_DEBUG=$debug
#  fi
#  APPNAME="$name"
#
#  # Create directory for instance config 
#  instdir=$base/appdata/$APPNAME
#  mkdir -p $instdir
#
#  # construct launch script
#  touch $instdir/prelaunch; chmod 755 $instdir/prelaunch
#  cat > $instdir/prelaunch << EOF
#  #!/bin/bash
#app=$config_dir/app.elf32
#mod=$config_dir/config.dtb
#EOF
#
#  # write ip 
#  let max=10+$count**2 # ip timeout
#  echo "MAX=$max" >> $instdir/prelaunch 
#  cat $base/scripts/ip >> $instdir/prelaunch
#
#  # kexec
#  touch $instdir/run; chmod 755 $instdir/run
#  cat > $instdir/run << EOF
##!/bin/bash
#app=/root/app.elf32
#mod=/root/config.dtb
#EOF
#  cat $base/scripts/kexec >> $instdir/run
#
#  # load isntances
#  for i in `seq 1 $count`; do
#    instid=$RANDOM
#
#    # Create director for copy-on-write images (if nessessary)
#    cowdir=$base/cowimgs/$APPNAME
#    mkdir -p $cowdir
#
#    qemu-img create -f qcow2 -b $sesalnx $cowdir/$instid.img >> /dev/null
#    FNT_IMG=$(readlink -f ${cowdir}/$instid.img)
#
#    # mount and run
#    mnt=$(readlink -f ${base}/$instdir)
#    $SESA_GET -i -c $mnt $APPNAME $FNT_IMG 1
#  done
#  return 0
#}


HPCloudConfigNodes()
{
  local khuser=$1
  local pnetids=$2
  local inet=$3
  local xnet=$4
  local conid=$5
  local num=$6
  local nodes="$7"
  local basedir=$KHCONSDIR/$conid

  # node construction 
  for n in ${nodes[@]}; do
    dir=$basedir/nodes/$n

    local ipstr=( $(tupleCmd echo Net "$n:*") )
    local ip=$( echo $ipstr | cut -d ':' -f 2 )
    echo $ip

    if [[ $ip == $FREENETADDR || ! $ip ]]; then
      echo "Error: attempting to connect to an unitilized node"
      exit 1
    fi

    ##### HPCLOUD VARIABLES ##################################
    user=ubuntu
    sesalnx_id=/opt/bin/hpcloud_jmcadden.pem
    app=/home/ubuntu/app.elf32
    config=/home/ubuntu/config.dtb
    sshops="-q -i $sesalnx_id -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no "
    #########################################################

    ## Load and run app on pre-allocated instance
    scp $sshops $SESA_CONFIG  $user@$ip:$config
    scp $sshops $SESA_IMG  $user@$ip:$app
    ssh $sshops $user@$ip sudo kexec -t multiboot-x86 \
        --module=$config -l $app
    xterm -e ssh $sshops -f $user@$ip sudo kexec -e 

  done
  return 0
}

HPCloudAllocNodes()
{
  local nodes="$1"
  local active=$(($(hpcloud servers | grep ACTIVE | wc -l)))


  for i in ${nodes[@]}
  do
    echo "Allocating node kh_$i"
    hpcloud servers:add "kh_"$i xsmall --key_name ssh
    let active=$active+1
  done


  while [[ $(hpcloud servers | grep ACTIVE | wc -l) -lt $active ]];
  do
    sleep 3
  done

  for i in ${nodes[@]}
  do
    ip=$(hpcloud servers -d " " kh_$i | grep ACTIVE | while read nid state fla img ip junk ; do echo $ip; done)
    locked_rm_netaddr "$i" "*" 
    locked_touch_netaddr "$i" "$ip" 
  done
  
  echo "Allocation complete. "
  return 0
}

HPCloudGetIps()
{

  local nodes="$1"
  for i in ${nodes[@]}
  do
    ip=$(hpcloud servers -d " " kh_$i | grep ACTIVE | while read nid state fla img ip junk ; do echo $ip; done)
    echo "\nStoring IPs $i $ip"
    locked_rm_netaddr "$i" "*" 
    locked_touch_netaddr "$i" "$ip" 
  done


}
 
HPCloudFreeApp()
{
  app=$1
  if [[ -z $app ]]; then
      echo "Error: No app name"
      exit 1
  fi

  local consoles=( $(tupleCmd echo Node "*:$app:*:*:*") )
  if [[ $consoles == "*:$app:*:*:*" ]];then
    exit 1
  fi

  for i in ${consoles[@]}
  do
    nodes+=($( echo $i | cut -d ':' -f 1 ))
  done

  HPCloudRebootNodes "${nodes[*]}"

  lock tuples
  locked_rm_nodes "*" "$1" "*" "*" "*" "*"
  for j in ${nodes[@]}
  do
    locked_touch_nodes "$j" "$FREEOWNER" "$FREEPNET"\
      "$FREEINETFLG" "$FREEXNETFLG" "$FREECONID" "$FREENETADDR"
  done
  unlock tuples
}


HPCloudFreeNodes()
{
  local nodes="$1"
  local remaining=$(($(hpcloud servers | grep ACTIVE | wc -l)))

  for i in ${nodes[@]}
  do
    echo "Freeing node kh_$i"
    hpcloud servers:remove "kh_"$i >/dev/null 2>&1
    let remaining=$remaining-1

  done

  while [[ $(hpcloud servers | grep ACTIVE | wc -l) -gt $remaining ]];
  do
    sleep 3
  done

  echo "Free complete."
  return 0
}

HPCloudRebootNodes()
{
  local nodes="$1"

  for i in ${nodes[@]}
  do
   echo "Rebooting node kh_$i"
   hpcloud servers:reboot "kh_"$i >/dev/null 2>&1
  done

  while [[ $(hpcloud servers | grep rebooting_hard | wc -l) -gt 0 ]];
  do
    sleep 3
  done

  echo "Reboot complete"
  return 0
}

MocConfigNodes()
{
  echo "MOC integration not yet functional"
  return 0
}

MocAllocNodes()
{
  echo "MOC integration not yet functional"
  return 0
}

function getTotalNodes
{
  echo $SESAMAXNODES
}

function getMyRank
{
  local rc

  if [[ -a $KHRANKFILE ]]
  then
     rc=$(cat $KHRANKFILE)
  fi
  echo $rc
}

#
# FIXME: This does not handle roleover and not sure it behaves well
#        with really big allocs
#
locked_getNewPNetIDs()
{
  local num=$1
  local rc

  if [[ -z $num ]]
  then
    num=1
  fi

  if [[ ! -e $KHPNETIDFILE ]]
  then
     echo $KHPNETIDSTART > $KHPNETIDFILE
  fi

  rc=$(cat $KHPNETIDFILE)

  if (( ($rc + ($num - 1)) > $KHPNETIDEND ))
  then
     echo "ERROR: locked_getNewPNetIDs: not enough id : NYI" >&2
     return 255
  fi
  echo $(( $rc + $num )) > $KHPNETIDFILE

  if (( $num > 1 ))
  then
    eval echo {${rc}..$(( $rc + ($num - 1) ))}
  else
    echo $rc
  fi

  return 0
}

locked_undoPnetIDs()
{
  local num=$1
  local rc
  local cur

  if [[ -z $num ]]
  then
    echo "USAGE: $FUNCNAME: <num>" >&2
    return 255
  fi

  if [[ -e $KHPNETIDFILE ]]
  then
    cur=$(cat $KHPNETIDFILE)
    echo $(( $cur - $num )) > $KHPNETIDFILE
    return 0
  fi
  return 255
}


locked_getNewConID()
{
  local rc

  if [[ ! -e $KHCONIDFILE ]]
  then
     echo $KHCONIDSTART > $KHCONIDFILE
  fi
  rc=$(cat $KHCONIDFILE)
  if (( $rc == $KHCONIDEND ))
  then
     echo "ERROR: locked_getNewConID: last id reached: NYI" >&2
     return 255
  fi
  echo $(( $rc + 1 )) > $KHCONIDFILE
  echo $rc
  return 0
}

locked_undoConID()
{
  local conid=$1
  local rc
  local cur

  if [[ -e $KHCONIDFILE ]]
  then
    cur=$(cat $KHCONIDFILE)

    # sanity check
    if (( ($conid + 1) == $cur ))
    then
      echo $conid > $KHCONIDFILE
      return 0
    fi
  fi
  return 255
}


function lock
{
    local lockname=$1
    local lockfile=$KHTUPLECTRLDIR/${lockname}.lock

    if [[ -z $lockname ]]
    then
      echo "USAGE: $FUNCNAME <lock>"  >&2
      return 255
    fi

    if [[ ! -d $KHTUPLECTRLDIR ]]
    then
      if ! mkdir -p $KHTUPLECTRLDIR
      then
         echo "ERROR: $FUNCNAME: $KHTUPLECTRLDIR does not exist "\
              "and cannot be created" >&2
         exit 255
      fi
    fi

    # Acquire lock
    lockfile -s1 $lockfile
}

function unlock
{
    local lockname=$1
    local lockfile=$KHTUPLECTRLDIR/${lockname}.lock

    if [[ -z $lockname ]]
    then
      echo "USAGE: $FUNCNAME <lock>"  >&2
      return 255
    fi
    # Release lock
    rm -f $lockfile
}

function locked_unchecked_tupleCreateType
{
     local type=$1
     local typedir=$KHTUPLEDIR/$type

     if [[ -d $typedir ]]
     then
         echo "ERROR: $FUNCNAME: $typedir already exists" >&2
         return 255
     fi

     if  ! mkdir -p $typedir
     then
        echo "ERROR: $FUNCNAME: could not create typedir" >&2
        return 255
     fi

}

function tupleCreateType
{
   local type=$1

   if [[ -z $type ]]
   then
     echo "USAGE: $FUNCNAME <type>"  >&2
     return 255
   fi

   lock tuples
      locked_unchecked_tupleCreateType $type
   unlock tuples
   return 0
}

locked_unchecked_tupleTypeExists()
{
  local type=$1
  local typedir=$KHTUPLEDIR/$type
  if [[ -d $typedir ]]
  then
    return 0
  else
    return 255
  fi
}

function tupleTypeExists
{
  local type=$1
  local rc=0

  if [[ -z $type ]]
  then
    echo "USAGE: $FUNCNAME <type>"  >&2
    return 255
  fi

  lock tuples
      locked_unchecked_tupleTypeExists $type
      rc=$?
  unlock tuples

  return $rc
}

locked_unchecked_tupleCmd()
{
  local cmd=$1
  local type=$2
  local tuplepattern=$3
  local rc=0

  cd $KHTUPLEDIR/$type

  if eval $cmd $tuplepattern 2>/dev/null
  then
    rc=0
  else
    #eval echo "ERROR: $FUNCNAME: $cmd $typedir/$tuplepattern: FAILED"  >&2
    rc=255
  fi

  return $rc
}

function tupleCmd
{
  local cmd=$1
  local type=$2
  local tuplepattern=$3
  local rc=0

  if [[ -z $cmd || -z $type || -z $tuplepattern ]]
  then
    echo "USAGE: $FUNCNAME <cmd> <type> <tuplepattern>" >&2
    return 255
  fi

  type -a $cmd >/dev/null 2>&1

  if (( $? != 0 ))
  then
    echo "ERROR: $FUNCNAME: $cmd is not a executable command"  >&2
    return 255
  fi

  lock tuples
     if locked_unchecked_tupleTypeExists $type
     then
       locked_unchecked_tupleCmd $cmd $type "$tuplepattern"
       rc=$?
     else
       echo "ERROR: $FUNCNAME: Tuple type $type does not exist"
       rc=255
      fi
  unlock tuples
  return $rc
}


#
# FIXME:  This is stupid and expensive on big lists
#         fix this to improve performance
#
function commalisttopat
{
  local cl="$1"
  local a

  if [[ -n $cl ]]
  then
    a=( ${cl//,/ } )
    if (( ${#a[@]} == 1 ))
    then
      echo "$cl"
    else
      echo "{$cl}"
    fi
  fi
}

function validkhuser
{
   local khuser=$1
   if [[ "$khuser" =~ "^[a-zA-Z]+[a-zA-Z0-9]*$" ]]
   then
     return 0
   else
     return 255
   fi
}

###  Node nodeid:owner:pnetids:inet:xnet:consid  ###
function locked_touch_nodes
{
  local nodeidpat="$1"
  local ownerpat="$2"
  local pnetidpat="$3"
  local inetflgpat="$4"
  local xnetflgpat="$5"
  local considpat="$6"

  if [[ -z $nodeidpat || -z $ownerpat || -z $pnetidpat || -z $inetflgpat ||
       -z $xnetflgpat || -z $considpat ]]
  then
     echo "USAGE: $FUNCNAME <nodeidpat> <ownerpat> <pnetidpat> <inetflgpat>"\
         " <xnetflgpat> <considpat>"
     return 255
  fi

  locked_unchecked_tupleCmd touch Node \
      "$nodeidpat:$ownerpat:$pnetidpat:$inetflgpat:$xnetflgpat:$considpat"
  return $?
}


###  node nodeid:owner:pnetids:inet:xnet:consid  ###
function locked_touch_netaddr
{
  local nodeidpat="$1"
  local netaddr="$2"

  if [[ -z $nodeidpat || -z $netaddr ]]
  then
     echo "usage: $funcname <nodeidpat> <netaddr>"
     return 255
  fi
  
  locked_unchecked_tupleCmd touch Net \
      "$nodeidpat:$netaddr" 
  return $?
} 


function locked_rm_netaddr
{
  local nodeidpat="$1"
  local netaddr="$2"

  if [[ -z $nodeidpat || -z $netaddr ]]
  then
     echo "usage: $funcname <nodeidpat> <netaddr>"
     return 255
  fi
  
  locked_unchecked_tupleCmd rm Net \
      "$nodeidpat:$netaddr" 
  return $?
} 

###  Node nodeid:owner:pnetids:inet:xnet:consid  ###
function locked_ls_nodes
{
  local nodeidpat="$1"
  local ownerpat="$2"
  local pnetidpat="$3"
  local inetflgpat="$4"
  local xnetflgpat="$5"
  local considpat="$6"

  if [[ -z $nodeidpat || -z $ownerpat || -z $pnetidpat || -z $inetflgpat ||
       -z $xnetflgpat || -z $considpat ]]
  then
     echo "USAGE: $FUNCNAME <nodeidpat> <ownerpat> <pnetidpat> <inetflgpat>"\
         " <xnetflg> <consid>"
     return 255
  fi

  locked_unchecked_tupleCmd ls Node \
      "$nodeidpat:$ownerpat:$pnetidpat:$inetflgpat:$xnetflgpat:$considpat"
  return $?
}

###  Node nodeid:owner:pnetids:inet:xnet:consid  ###
function locked_rm_nodes
{
  local nodeidpat="$1"
  local ownerpat="$2"
  local pnetidpat="$3"
  local inetflgpat="$4"
  local xnetflgpat="$5"
  local considpat="$6"

  if [[ -z $nodeidpat || -z $ownerpat || -z $pnetidpat || -z $inetflgpat ||
       -z $xnetflgpat || -z $considpat ]]
  then
     echo "USAGE: $FUNCNAME <nodeidpat> <ownerpat> <pnetidpat> <inetflgpat>"\
         " <xnetflgpat> <considpat>"
     return 255
  fi

  locked_unchecked_tupleCmd rm Node \
      "$nodeidpat:$ownerpat:$pnetidpat:$inetflgpat:$xnetflgpat:$considpat"
  return $?
}

###   User name:cred  ####
function locked_touch_users
{
  local userpat="$1"
  local credpat="$2"

  if [[ -z $userpat || -z $credpat ]]
  then
    echo "USAGE: $FUNCNAME <userpat> <credpat>"
    return 255
  fi
  locked_unchecked_tupleCmd touch User "${userpat}:$credpat"
  return $?
}

###   User name:cred  ####
function locked_ls_users
{
  local userpat="$1"
  local credpat="$2"

  if [[ -z $userpat || -z $credpat ]]
  then
    echo "USAGE: $FUNCNAME <userpat> <credpat>"
    return 255
  fi
  locked_unchecked_tupleCmd ls User "${userpat}:$credpat"
  return $?
}

###   User name:cred  ####
function locked_rm_users
{
  local userpat="$1"
  local credpat="$2"

  if [[ -z $userpat || -z $credpat ]]
  then
    echo "USAGE: $FUNCNAME <userpat> <credpat>"
    return 255
  fi
  locked_unchecked_tupleCmd rm User "${userpat}:$credpat"
  return $?
}

###  Pnet pnetid:owner  ###
function locked_touch_pnets
{
  local pnetidpat="$1"
  local ownerpat="$2"

  if [[ -z $pnetidpat || -z $ownerpat ]]
  then
    echo "USAGE: $FUNCNAME <pnetidpat> <ownerpat>"
    return 255
  fi
  locked_unchecked_tupleCmd touch Pnet "${pnetidpat}:$ownerpat"
  return $?
}

###  Pnet pnetid:owner  ###
function locked_ls_pnets
{
  local pnetidpat="$1"
  local ownerpat="$2"

  if [[ -z $pnetidpat || -z $ownerpat ]]
  then
    echo "USAGE: $FUNCNAME <pnetidpat> <ownerpat>"
    return 255
  fi
  locked_unchecked_tupleCmd ls Pnet "${pnetidpat}:$ownerpat"
  return $?
}

###  Pnet pnetid:owner  ###
function locked_rm_pnets
{
  local pnetidpat="$1"
  local ownerpat="$2"

  if [[ -z $pnetidpat || -z $ownerpat ]]
  then
    echo "USAGE: $FUNCNAME <pnetidpat> <ownerpat>"
    return 255
  fi
  locked_unchecked_tupleCmd rm Pnet "${pnetidpat}:$ownerpat"
  return $?
}

locked_dealloc_pnetids()
{
   local users="$1"
   local pnetids="$2"
   local num="$3"
   local pnetpat
   local userpat

   if [[ -z $users || -z $pnetids || -z $num ]]
   then
      echo "ERROR:  locked_dealloc_pnetids <user> <comma list of pnetids> <num in list>"
      return 255
   fi

   pnetpat="$(commalisttopat $pnetids)"
   userpat="$(commalisttopat $users)"
   locked_rm_pnets "$pnetpat" "$userpat"

   locked_undoPnetIDs $num
   return 0
}

# accepts a comma seperated list of users
function locked_allocate_pnetids
{
   local users="$1"
   local -i num=$2
   local userpat
   local u
   local pnetids
   local pnetpat
   local rc

   if [[ -z $users ]] || (( $num <= 0 ))
   then
      echo "USAGE: $FUNCNAME <comma seperated list of users> <num>"
      return 255
   fi

   userpat="$(commalisttopat $users)"

   if ! locked_ls_users "${userpat}" "*" >/dev/null 2>&1
   then
      echo "ERROR: $FUNCNAME some of the users specified do not exist."
      return 255
   fi

   pnetids="$(locked_getNewPNetIDs $num)"
   pnetids=${pnetids// /,}
   pnetpat="$(commalisttopat $pnetids)"

   if (( $? != 0 ))
   then
     return 255
   fi

   locked_touch_pnets "$pnetpat" "$userpat"
   rc=$?
   echo "$pnetids"
   return $rc
}

locked_initFreeNodes()
{
   local maxnoderank
   local nodepat
   local myrank

   # nodes are zero indexed so we start from zero and go to number of nodes - 1
   maxnoderank=$(($(getTotalNodes) - 1))
   nodepat="{0..$maxnoderank}"
   locked_touch_nodes "$nodepat" "$FREEOWNER" "$FREEPNET"\
                      "$FREEINETFLG" "$FREEXNETFLG" "$FREECONID" "$FREENETADDR"
   locked_touch_netaddr "$nodepat" "$FREENETADDR" 

   myrank=$(getMyRank)
   if [[ -n $myrank ]] && (( $myrank <= $maxnoderank ))
   then
     locked_rm_nodes "$myrank" "*" "*" "*" "*" "*"
   fi

   return 0
}

function locked_checkAndSetupTypes
{
    # check to see that all the Tuple types we use
    # exist and if not create them
    # User name:cred
    if ! locked_unchecked_tupleTypeExists User
    then
       locked_unchecked_tupleCreateType User
    fi

    # Pnet pnetid:owner
    if ! locked_unchecked_tupleTypeExists Pnet
    then
       locked_unchecked_tupleCreateType Pnet
    fi

    # Net nodeid:networkid
    if ! locked_unchecked_tupleTypeExists Net
    then
       locked_unchecked_tupleCreateType Net
    fi

    # Node nodeid:owner:pnetids:inet:xnet:consid
    if ! locked_unchecked_tupleTypeExists Node
    then
       locked_unchecked_tupleCreateType Node
       locked_initFreeNodes
    fi
}

function SESASetupEnvironment
{

  lock tuples
    locked_checkAndSetupTypes    
  unlock tuples 

  maxnoderank=$(($(getTotalNodes) - 1))
  nodepat="`seq 0 $maxnoderank`"
  $allocNodes "$nodepat"
}

function acquireNodes
{
  local num=$1
  local freelist
  local nodes
  local khuser
  local conid
  local -i createpnets=-1
  local pnetids
  local pnetidspat
  local curpnetids
  local crepnetids
  local -i inet=0
  local -i xnet=0
  local cred=nocredentials
  local -i newuser=0

  local    origargs="$@"
  local -i optcount=0

  while getopts "n:p:ixc:h" OPT
  do
    case $OPT in
      ("n") pnetids="$OPTARG"; (( optcount=optcount + 2));;
      ("p") createpnets="$OPTARG"; (( optcount=optcount + 2));;
      ("i") inet=1; (( optcount=optcount + 1));;
      ("x") xnet=1; (( optcount=optcount + 1));;
      ("c") cred="$OPTARG"; (( optcount=optcount + 2));;
      ("h") usage  acquireNodes; exit 255;;
    esac
  done

  shift $optcount

  khuser=$1
  if [[ -z $khuser ]]
  then
     echo "ERROR:  must specify user" >&2
     usage acquireNodes
     exit 255
  fi

  if ! validkhuser $khuser
  then
    echo "ERROR: invalid user $khuser" >&2
    usage acquireNodes
    exit 255
  fi

  num=$2
  if [[ -z $num ]]
  then
    num=1
  fi

  if (( $num == 0 ))
  then
    echo "ERROR: allocation of 0 nodes not supported" >&2
    usage acquireNodes
    exit 255
  fi

  lock tuples

    locked_checkAndSetupTypes

    if ! locked_ls_users "$khuser" "*" >/dev/null
    then
      locked_touch_users "$khuser" "$cred"
      newuser=1
    fi

    pnetidspat="$(commalisttopat $pnetids)"
    curpnetids=( $(locked_ls_pnets "*" "$khuser") )

    if [[ -n $pnetids ]]
    then
      if ! locked_ls_pnets "$pnetidspat" "$khuser" > /dev/null
      then
        echo "ERROR: $FUNCNAME:  $khuser does not own all the network ids"\
             " specified ($pnetids). The current set of network ids"\
             " $khuser owns is: " ${curpnetids[@]}
        if (( newuser == 1 )); then locked_rm_users "$khuser" "$cred"; fi
        unlock tuples
        return 255
      fi
    fi

    if (( $newuser == 1 && $createpnets == -1 ))
    then
      createpnets=1
    fi

    if (( $createpnets == -1 )) && [[ -z $pnetids ]]
    then
      if (( ${#curpnetids[@]} == 1 ))
      then
        pnetids=${curpnetids[0]%%:*}
      else
        echo "ERROR:$FUNCNAME: must either specify one or more of the existing"\
           " private networks (${curpnetids[@]}) for $khuser with the -n flage"\
           " or use -c to specify the number of new network ids to create."
        unlock tuples
        return 255
      fi
    fi

    if  (( $createpnets >= 0 ))
    then
      crepnetids="$(locked_allocate_pnetids "$khuser" $createpnets)"
      if [[ -n $pnetids ]]
      then
        pnetids="$pnetids,$crepnetids"
      else
        pnetids="$crepnetids"
      fi
    fi
    pnetidspat="$(commalisttopat $pnetids)"

    conid=$(locked_getNewConID)
    if (( $? != 0 ))
    then
      echo "ERROR: acquireNodes: unable to create a new console channel for"\
           " you :-(" >&2
      if (( $newuser == 1 )); then locked_rm_users "$khuser" "$cred"; fi
      if (( $createpnets > 0 )); then locked_dealloc_pnetids "$khuser" "$crepnetids" "$createpnets"; fi
      unlock tuples
      return 255
    fi

    # to keep things fast we cheat :-( and do direct commands on Node tuple dir
    cd $KHTUPLEDIR/Node
    freelist=( $(ls *:$FREEOWNER:* 2>/dev/null | sort -n) )
    if (( ${#freelist[@]} >= $num ))
    then
        nodes=( ${freelist[@]:0:$num} )
        rm ${nodes[@]}
        touch ${nodes[@]//:*/:$khuser:$pnetids:$inet:$xnet:$conid}
    fi

    if [[ -z $nodes ]]
    then
      if (( $newuser == 1 )); then locked_rm_users "$khuser" "$cred"; fi
      if (( $createpnets > 0 )); then locked_dealloc_pnetids "$khuser" "$crepnetids" "$createpnets"; fi
      locked_undoConID $conid
      echo "not enough nodes available"
      unlock tuples
      return 255;
    fi
    
  unlock tuples 
  
 # echo "conid:$conid"
 # echo "pnetids:$pnetids"
 # echo "nodes:${nodes[*]//:*/}
 
  assignNodes "$khuser" "$pnetids" $inet $xnet $conid $num "${nodes[*]//:*/}"
  if [[ -e /tmp/khmonpipe ]]
  then
    echo "acquireNodes" > /tmp/khmonpipe
    echo "acquireNodes" > /tmp/khmonpipe
    echo "acquireNodes" > /tmp/khmonpipe
  fi
  return 0;
}

usage()
{
  local func=$1
  if [[ -z $func ]]
  then
     echo "USAGE:  ${0##*/} func args" >&2
     grep '^function' $0
  else
     case "$func" in
         'acquireNodes')
            echo "USAGE: ${0##*/} acquireNodes [-n netid[,netid,...]]"\
" [-p num] [-i] [-x] [-c credentials] user [num of nodes]" >&2
            echo "     -n netid[,netid,...] : add the nodes to the existing"\
" Private networks identified" >&2
            echo "                by netid" >&2
            echo "     -p num   : create num new Private networks for the"\
" nodes">&2
            echo "     -i       : add nodes to the Internal public network" >&2
            echo "     -x       : add nodes to the External network" >&2
            echo "     -c cred  : associated credentials with user" >&2
            echo "     user     : user to get the nodes for" >&2
            echo "  num of nodes: number of nodes to get default is 1" >&2
            ;;
          *)
            usage
            ;;
     esac
  fi
}

processargs()
{
  if [[ $# == 0 ]]
  then
    usage
    exit 255
  fi

  dofunc=$1
}

processargs "$@"
shift

$dofunc "$@"

exit $?
